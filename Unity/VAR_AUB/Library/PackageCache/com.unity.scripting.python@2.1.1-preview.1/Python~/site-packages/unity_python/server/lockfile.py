from __future__ import division, print_function

import sys

###
# Provide a cross-platform lockfile for win32 or *nix.
# Usage:
#   lock = lockfile.lockfile("path")
#   ...
#   lock.release()
# Used by the server to ensure only one server runs at a time on the
# same socket file.

if sys.platform == 'win32':
    import ctypes
    runtime = ctypes.windll.kernel32
    CreateFileA = runtime.CreateFileA
    CreateFileA.argtypes = (
        ctypes.wintypes.LPCSTR, # path
        ctypes.wintypes.DWORD, # access
        ctypes.wintypes.DWORD, # share
        ctypes.c_void_p, # security (null)
        ctypes.wintypes.DWORD, # create
        ctypes.wintypes.DWORD, # flags
        ctypes.c_void_p, # template (null)
    )
    CloseHandle = runtime.CloseHandle
    CloseHandle.argtypes = (
        ctypes.wintypes.HANDLE,
    )

    def acquire(path):
        """
        Return a handle to the lock file or None.

        Raise IOError if we can't lock.
        """
        h = CreateFileA(
            path, 
            0x80000000, # GENERIC_WRITE
            0, # share with nobody -- lock it
            None, # default security
            2, # CREATE_ALWAYS
            0x100 | 0x04000000, # TEMPORARY and DELETE_ON_CLOSE
            None, # no template
        )
        if int(h) < 0:
            raise IOError(runtime.GetLastError(), "Unable to acquire lock file " + path)
        else:
            return h

    def release(h):
        """
        Release the lock handle.
        """
        if h is None:
            return
        CloseHandle(h)

else:
    import fcntl
    import os

    def acquire(path):
        """
        Return a file object to the lock file, or None.

        Raise IOError if we can't lock.
        """
        f = open(path, "w")
        fcntl.lockf(f, fcntl.LOCK_EX | fcntl.LOCK_NB)
        return f

    def release(f):
        """
        Release a lock file object.
        """
        # important: remove the directory entry before unlocking
        os.remove(f.name)
        fcntl.lockf(f, fcntl.LOCK_UN)
        f.close()

class lockfile(object):
    def __init__(self, path):
        self._lock = acquire(path)

    def release(self):
        release(self._lock)
