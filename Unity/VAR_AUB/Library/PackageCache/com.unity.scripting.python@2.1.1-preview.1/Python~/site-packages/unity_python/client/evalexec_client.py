# Though Python for Unity currently uses Python 2.7,
# We are ready for the coming of Python 3.x.
from __future__ import division, print_function

# This import fixes our sys.path if it's missing the package root.
# It also adds threading.get_ident if it's missing.
import unity_client

import os
import socket
import sys
import threading
import time

try_to_connect = True

# A client requires a unique name.
client_name = "com.unity.scripting.python.clients.evalexec"

class EvalExecClientService(unity_client.UnityClientService):
    """
    A generic client that allows eval, exec, and access to the globals.

    Override the name and you can use this service to connect to any framework.
    """
    def __init__(self):
        self._globals = dict()

    # The client name is used for logging and calls from Unity.
    def exposed_client_name(self):
        return client_name

    def exposed_globals(self):
        return self._globals

    # Eval function which can be called from Unity.
    # The text will print on the client's stdout.
    def exposed_eval(self, string):
        print("eval({})".format(string))
        return eval(string, self._globals)

    def exposed_exec(self, string):
        print("exec({})".format(string))
        exec(string, self._globals)

    # The on_server_shutdown service tells the client that Unity has disconnected from it.
    # The following function determines how this is handled.
    # The 'invite_retry' flag is a bloolean.
    def exposed_on_server_shutdown(self, invite_retry):
        global try_to_connect
        try_to_connect = invite_retry
        super(EvalExecClientService, self).exposed_on_server_shutdown(invite_retry)

"""
This client is set up to be run from the command-line, or via C# API (PythonRunner.SpawnClient).
An exterior application could also be made to connect to Unity.
"""
if __name__ == '__main__':
    # This is the loop which maintains the connection to Unity.
    # It handles reconnection, and whether it is needed (try_to_connect may be false).
    while try_to_connect:
        time.sleep(0.5)
        try:
            # Here starts a new thread connecting to Unity.
            # It listens to incoming messages, and uses the defined service.
            c = unity_client.connect(EvalExecClientService)
        except socket.error:
            print("failed to connect; try again later")
            continue

        print("connected")
        try:
            c.thread.join() # Wait for KeyboardInterrupt (^c or server quit)
        except KeyboardInterrupt:
            c.close()
            c.thread.join() # Wait for the thread to notice the close()
        print("disconnected")
